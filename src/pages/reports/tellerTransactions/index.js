import moment from "moment";
import { useRouter } from "next/router";
import { useEffect, useState } from "react"
import { GetTallyPerDraw } from "../../api/tally";
import { GetSupervisor } from "../../api/supervisor";
import { GetActiveTellers, GetGrossPerDraw, GetTellerGrossPerDay } from "../../api/reports";
import { Button, Form, Input, Radio, Table } from "antd";
import { EyeOutlined, LockOutlined, PrinterOutlined, RollbackOutlined, UserOutlined } from "@ant-design/icons";
import Layout from "../../layouts";
import Head from "next/head";



export default function Home() {
    const [from, setFrom] = useState(moment().format('yyyy-MM-DD'))
    const [to, setTo] = useState(moment().add(1, 'days').format('yyyy-MM-DD'))
    const router = useRouter();
    const [form] = Form.useForm();
    const { drawTime } = router?.query;
    const { drawId } = router?.query;
    const { isOffline } = router?.query;
    const [data, setData] = useState([])
    const [spvrData, setspvrData] = useState([])
    const [isfetching, Setisfetching] = useState(false);
    let TotalL2 = 0;
    let TotalL3 = 0;
    let TotalD4 = 0;
    let TotalP3 = 0;
    useEffect(() => {


        handleGetSpvr()
        handleGetData()
    }, [])



    const handleGetSpvr = async () => {

        try {
            let ApiResponse = await GetSupervisor()

            setspvrData(ApiResponse.data?.data)
        }
        catch (error) {


        }

    }

    const handleGetData = async () => {
        Setisfetching(true);
        try {
            let ApiResponse = await GetActiveTellers({
                from: from,
                to: to
            })

            setData(ApiResponse.data?.data)
        }
        catch (error) {


        }
        Setisfetching(false);
    }


    const handleChange = async (pagination, filters, sorter) => {

        // console.log( filters?.fullName);
        // // filters?.map((item) =>{

        // //   console.log( item);

        // // }); 


        Setisfetching(true);

        setInterval(() => {
            Setisfetching(false);

        }, 2000);

    };

    function displaySpvr(supervisor) {
        let spvr = '';
        spvrData?.filter((item) => {
            if (supervisor == item?.id) {
                spvr = item?.username
            }
        })
        return spvr

    }


    const columns = [
        {
            title: 'Supervisor',
            dataIndex: 'username',
            key: 'username',
            width: 130,
            render: (dom, entity) => {
                return displaySpvr(entity?.supervisor)


            }
        },

        {
            title: 'Teller',
            dataIndex: 'username',
            key: 'username',
            width: 130,
            render: (dom, entity) => {

                return dom

            }
        },
        {
            title: 'Outlet',
            dataIndex: 'outlet',
            key: 'outlet',
            width: 130,
            render: (dom, entity) => {

                return dom

            }
        },
        {
            title: 'Action',
            dataIndex: 'outlet',
            key: 'outlet',
            width: 20,
            render: (dom, entity) => {

                return <Button onClick={() => {



                    router.push({
                        pathname: `/reports/tellerTransactions/${entity?.id}`,
                        query: {
                            username: entity.username,
                            outlet: entity.outlet
                        },
                    }, `/reports/tellerTransactions/${entity?.id}`, {})

                }} className="" type="primary"><EyeOutlined />View</Button>

            }
        },


    ];


    const onFinish = async (values) => {
        Setisfetching(true)
        try {
            setData(data?.filter((item, key) => {

                if (item?.username.indexOf(values?.username.toLowerCase()) != -1) {

                    return item
                }

            }))
        }
        catch (error) {
            console.log(error);
        }

        Setisfetching(false)

    };
    const onFinishFailed = (errorInfo) => {
        console.log('Failed:', errorInfo);
    };
    return (


        <>

            <Layout>

                <Head>
                    <title>EEDO</title>
                    <meta name="description" content="Generated by create next app" />
                    <meta name="viewport" content="width=device-width, initial-scale=1" />
                    <link rel="icon" href="/favicon.ico" />
                </Head>


                <div>
                    <p className="mt-5 mb-5 text-center text-lg">Teller Transactions</p>


                    <div>

                        <div className="mb-2">
                            <Form form={form} name="horizontal_login" layout="inline" onFinish={onFinish}
                                onFinishFailed={onFinishFailed}
                                autoComplete="off" >
                                <Form.Item
                                    name="username"
                                    rules={[
                                        {
                                            required: true,
                                            message: 'Please input teller username!',
                                        },
                                    ]}
                                >
                                    <Input  placeholder="Username" />
                                </Form.Item>
                                <Form.Item >
                                    <Button
                                        type="primary"
                                        htmlType="submit"

                                    >
                                        Search
                                    </Button>
                                </Form.Item>

                                <Form.Item >
                                    <Button
                                        type="default"
                                        onClick={(() => {
                                            handleGetData()
                                        })}

                                    >
                                        Refresh
                                    </Button>
                                </Form.Item>
                            </Form>
                        </div>
                        <Table dataSource={data} columns={columns} loading={isfetching} onChange={handleChange} scroll={{
                            x: 800,
                        }} />
                    </div>
                </div>

            </Layout>
        </>


    )




}